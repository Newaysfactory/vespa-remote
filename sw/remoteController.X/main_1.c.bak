/*
 * File:   main.c
 * Author: Adriano Arcadipane
 *
 * Created on December 25, 2024, 6:51 PM
 */


#include <xc.h>

// PIC10F222 Configuration Bit Settings

// CONFIG
#pragma config IOSCFS = 4MHZ    // Internal Oscillator Frequency Select bit (4 MHz)
#pragma config MCPU = OFF       // Master Clear Pull-up Enable bit (Pull-up disabled)
#pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT disabled)
#pragma config CP = OFF         // Code protection bit (Code protection off)
#pragma config MCLRE = OFF      // GP3/MCLR Pin Function Select bit (GP3/MCLR pin function is digital I/O, MCLR internally tied to VDD)

#define _XTAL_FREQ 4000000      // Internal frequency 4 MHz (for delay function)

#define OBSERVATION_CYCLES 1500        //
#define IGNORED_CYCLES 0
#define CYCLE_DELAY_US 1000      

#define TRUE  1
#define FALSE 0

// I/O definitions
#define BRAKE_LIGHT GP3       // Pulsante collegato a GP1
#define OUT1 GP0              // LED collegato a GP0
#define OUT2 GP1              // LED collegato a GP0
#define OUT3 GP2              // LED collegato a GP0

void init(){
    //REQUIREMENTS TO MAKE PINS AVAILABLE IN DIGITAL MODE
    ADCON0bits.ANS0 = 0;  //Disable analog input 
    ADCON0bits.ANS1 = 0;  //Disable analog input 
    OSCCALbits.FOSC4 = 0; //Disable TMR input from GP2
    
    //0 GPWU: Enable Wake-up On Pin Change bit (GP0, GP1, GP3)
    //1 GPPU: Disable Weak Pull-ups bit (GP0, GP1, GP3)
    //0 T0CS: Timer0 Clock Source Select bit - Transition on internal instruction cycle clock, FOSC/4
    OPTION = 0b01011111;

    // Configura GP0, GP1, GP2 come uscite digitale, GP3 come ingresso
    TRISGPIO = 0b11111000;    // (0 = output, 1 = input)
    GPIO = 0b00000000;        // Inizializza i pin a livello basso (0)
}

void main(void) {
    unsigned char rising_edges_cnt = 0;
    unsigned char iii = 0;
    unsigned int cycle = 0;
    unsigned char debounce_counter = 0;    // Contatore per debounce
    unsigned char prev_state = FALSE;
    init();
    
    OUT1 = 1;    //REMOVE
    OUT2 = 1;
    OUT3 = 1;
    __delay_ms(10);
    OUT1 = 0;
    OUT2 = 0;
    OUT3 = 0;
    
    
    
    while (1) {

        if((STATUSbits.GPWUF == 1) && (STATUSbits.nTO == 1) && (STATUSbits.nPD == 0)){
            // Execute only if the reset is due to a change on GP3.
            // Condition from the datasheet
            
            //OUT3 = 1;
            
            while (cycle < OBSERVATION_CYCLES){
                //For a predefined time
                
                if ((BRAKE_LIGHT == 1) && (cycle > IGNORED_CYCLES)){
                    if (debounce_counter < 150) {     // Conta fino a 10 (debounce ~10 ms)
                        debounce_counter++;          // Incrementa contatore debounce
                    } else if (prev_state == FALSE) {    // Dopo il debounce verifica fronte di salita
                        rising_edges_cnt++;          // Incrementa conteggio fronti
                        prev_state = TRUE;              // Aggiorna stato precedente
                    }
                } else {                             // Pulsante rilasciato
                    debounce_counter = 0;            // Resetta contatore debounce
                    prev_state = FALSE;                  // Stato precedente torna basso
                }
                                  
                cycle++;
                __delay_us(CYCLE_DELAY_US);
            }
            
            if (rising_edges_cnt == 1){
                OUT1 = 1;
            } else if (rising_edges_cnt == 2){
                OUT2 = 1;
            } else if (rising_edges_cnt == 3){
                OUT3 = 1;
            }else {
                ; //Do nothing
            }
            
            __delay_ms(1000);
            
            /*
            //OUT3 = 0;
            for (iii=0; iii<rising_edges_cnt; iii++){
                OUT1 = 1;
                __delay_ms(100);
                OUT1 = 0;
                __delay_ms(200);
            }
            */
        }
        
        //Set all outputs low
        OUT1 = 0;
        OUT2 = 0;
        OUT3 = 0;
        SLEEP();  //Sleep until waked up by a change on GP3
    }
}
